## 二分答案
 - require: C++11
 - [x] 封装
 - [x] 测试

对函数的二分查找。对单调函数 `getval(x)`，在 `[first, last)` 范围查找 `x` 的所在位置。

### `x` 离散  <!-- omit in toc -->

```cpp
namespace penalg {

template <class Tx, class Ty, class Fn, class Comp = decltype(less<Ty>())>
Tx lower_bound(Tx l, Tx r, Fn f, const Ty &val, Comp comp = less<Ty>()) {
    Tx len = r - l;
    while (len > 0) {
        Tx half = len >> 1;
        Tx mid = l + half;
        if (comp(f(mid), val)) {
            l = mid + 1;
            len = len - half - 1;
        } else
            len = half;
    }
    return l;
}

template <class Tx, class Ty, class Fn, class Comp = decltype(less<Ty>())>
Tx upper_bound(Tx l, Tx r, Fn f, const Ty &val, Comp comp = less<Ty>()) {
    Tx len = r - l;
    while (len > 0) {
        Tx half = len >> 1;
        Tx mid = l + half;
        if (comp(val, f(mid)))
            len = half;
        else {
            l = mid + 1;
            len = len - half - 1;
        }
    }
    return l;
}

} // namespace penalg

// demo
int main() {
    vector<int> a = {7, 5, 5, 5, 3, 3, 3, 1, 1, 1};
    cout << penalg::upper_bound(
        0, 10, [&](int i) { return a[i]; }, 1, greater<int>());
}
```

### `x` 连续

```cpp
namespace penalg {

template <class Tx, class Ty, class Fn, class Comp = decltype(less<Ty>())>
Tx lowerbound(Tx l, Tx r, Fn f, const Ty &val, Comp comp = less<Ty>()) {
    Tx len = r - l;
    for (int i = 0; i < 30; i++) {
        Tx half = len / 2;
        Tx mid = l + half;
        if (comp(f(mid), val)) {
            l = mid;
            len = len - half;
        } else
            len = half;
    }
    return l;
}

} // namespace penalg
```