## 二分答案
 - require: C++11
 - [x] 封装
 - [x] 测试

基于函数的二分查找。对给定函数的 `y`，二分查找 `x`

### 离散  <!-- omit in toc -->

```cpp
template <typename Tx, typename Ty, typename Fn,
          typename Comp = decltype(less<Ty>())>
Tx upperbound(Fn getval, Tx first, Tx last, const Ty &val,
              Comp comp = less<Ty>()) {
    Tx len = last - first;
    while (len > 0) {
        Tx half = len >> 1;
        Tx middle = first + half;
        if (comp(val, getval(middle)))
            len = half;
        else {
            first = middle + 1;
            len = len - half - 1;
        }
    }
    return first;
}

template <typename Tx, typename Ty, typename Fn,
          typename Comp = decltype(less<Ty>())>
Tx lowerbound(Fn getval, Tx first, Tx last, const Ty &val,
              Comp comp = less<Ty>()) {
    Tx len = last - first;
    while (len > 0) {
        Tx half = len >> 1;
        Tx middle = first + half;
        if (comp(getval(middle), val)) {
            first = middle + 1;
            len = len - half - 1;
        } else
            len = half;
    }
    return first;
}

// demo
int main() {
    vector<int> a = {7, 5, 5, 5, 3, 3, 3, 1, 1, 1};
    cout << upperbound([&](int i) { return a[i]; }, 0, 10, 1, greater<int>());
}
```
