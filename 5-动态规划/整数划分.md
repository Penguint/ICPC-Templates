## 整数划分

1. n 分成 正整数之和 的划分数

```c++
// dp[i][j] := i 划分成每个正整数不超过 j 的划分方案数
dp[*][*] = 0;
dp[0][*] = 1; // 无意义 但递推中会被调用到

dp[i][j] = j <= i ?
            dp[i - j][j] + // 含 j 的方案数
            dp[i][j - 1]   // 不含 j 的方案数
           :
            dp[i][i];      // (j > i)
                 
ans = dp[n][n];
```

2. n 分成 **不同**正整数之和 的划分数

```c++
// dp[i][j] := i 划分成不同且每个正整数不超过 j 的划分方案数
dp[*][0] = 0;
dp[0][*] = 1; // 无意义 但递推中会被调用到

dp[i][j] = i >= j ?
            dp[i - j][j - 1] + // 含 j 的方案数
            dp[i][j - 1]       // 不含 j 的方案数
           :
            dp[i][i];          // (j > i)
                 
ans = dp[n][n];
```

3. n 分成 最大不超过 k 的正整数之和 的划分数

同 2 

```c++
// dp[i][j] := i 划分成每个正整数不超过 j 的划分方案数
dp[0][*] = 0;
dp[*][0] = 0;
dp[0][0] = 1;

dp[i][j] = i >= j ?
            dp[i - j][j - 1] + // 含 j 的方案数
            dp[i][j - 1]       // 不含 j 的方案数
           :
            dp[i][i];          // (j > i)
                 
ans = dp[n][n];
```

4. n 分成 奇正整数之和的划分数

```c++
// dp[i][j] := i 划分成每个正整数不超过 j 的划分方案数
dp[*][*] = 0;
dp[0][*] = 1;

dp[i][j] = j % 2 ? (           // 奇数 正常判断
            j <= i ?
                dp[i - j][j] + // 含 j 的方案数
                dp[i][j - 1]   // 不含 j 的方案数
            :
                dp[i][i];)     // (j > i)
           : 
            dp[i][j - 1];      // 偶数 等于上一个奇数

ans = dp[n][n];
```

5. n 分成 k 个正整数之和的划分数

```c++
// dp[i][j] := i 划分成 j 个正整数的划分方案数
dp[0][*] = 0;
dp[*][0] = 0;
dp[0][0] = 1;  

dp[i][j] = i >= j ? 
            dp[i - 1][j - 1] + // 这 j 个数中含 1
            dp[i - j][j]       // 这 j 个数中不含 1
           :
            0;                 // (j > i)

ans = dp[n][k];
```

6. n 分成 k 个非负整数之和的划分数 = n 分成 不超过 k 个正整数之和的划分数

单独 

```c++
// dp[i][j] := 划分成 j 个非负整数的划分方案数
dp[*][0] = 0;
dp[0][*] = 1; // 有意义 0 + 0 + 0 一种方案

dp[i][j] = i >= j ? 
            dp[i][j - 1] + // 这 j 个数中含 0
            dp[i - j][j]   // 这 j 个数中不含 0
           :
            dp[i][i];
            
ans = dp[n][k];
```

5 + 求和

```c++
// dp[i][j] := i 划分成 j 个正整数的划分方案数
dp[*][0] = 0;
dp[0][*] = 0;
dp[0][0] = 1;

dp[i][j] = i >= j ? 
            dp[i - 1][j - 1] + // 这 j 个数中含 1
            dp[i - j][j]       // 这 j 个数中不含 1
           :
            0;                 // (j > i)

ans = sum(dp[n][0~k]);
```

7. n 分成 k 个 至少为 c 的整数之和的划分数

利用 6

```
n = (0 + c) + (0 + c) + (1 + c) + (2 + c) + ...
n - k * c = 0 + 0 + 1 + 2 + ...
```

```c++
// dp[i][j] := 划分成 j 个非负整数的划分方案数
dp[*][0] = 0;
dp[0][*] = 1; // 有意义 即 0 = 0 + 0 + ... + 0 一种方案

dp[i][j] = i >= j ? 
            dp[i][j - 1] + // 这 j 个数中含 0
            dp[i - j][j]   // 这 j 个数中不含 0
           :
            dp[i][i];
            
ans = dp[n - k * c][k];
```