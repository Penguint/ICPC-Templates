## 快速幂 qpow
 - require: c++98
 - [x] 封装
 - [ ] 测试

### 二分 O(log n)
```cpp
ll qpow(ll a, ll b, ll mod = mod) {
    ll res = 1;
    a %= mod;
    while (b) {
        if (b & 1)
            res = res * a % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return res;
}

ll qpow(ll a, ll b, ll mod = mod) {
    if (!b) 
        return 1;
    ll ns = qpow(a, b >> 1);
    ns = ns * ns % mod;
    if (b & 1) 
        ns = ns * a % mod;
    return ns;
}

ll qmul(ll a, ll b, ll mod = mod) {
    ll res = 0;
    a %= mod;
    while (b) {
        if (b & 1)
            res = (res + a) % mod;
        a = (a + a) % mod;
        b >>= 1;
    }
    return res;
}

ll qmul(ll a, ll b, ll mod = mod) {
    if (!b) 
        return 0;
    ll ns = qmul(a, b >> 1);
    ns = (ns + ns) % mod;
    if (b & 1) 
        ns = (ns + a) % mod;
    return ns;
}

```

### 分块 O(1) (确定底数)

$$ a^n = a^{S \lfloor{\frac{n}{S}}\rfloor + ( n \mod s)} = a^{S \lfloor{\frac{n}{S}}\rfloor} \cdot a^{( n \mod s)} = f_{a,1}(\lfloor{\frac{n}{S}}\rfloor) \cdot f_{a,2}(n \mod S)$$ 

```cpp

int f_1[2][100005], f_2[2][100005]; // 2 共2个底数

inline int block_pow(int t, int b) { // t = 0 第一个底数, t = 1 第二个底数
    return (ll)f_1[t][b >> 15] * f_2[t][b & S] % P;
}

void get_block_pow(int S, vector<ll> a, int t)
    f_1[t][0] = f_2[t][1] = 1;
    for (int i = 1; i <= S; ++i)
        f_2[t][i] = (ll)f_2[t][i - 1] * A % mod,
    f_1[t][1] = (ll)f_2[t][S] * A % mod;
    for (int i = 2; i <= S; ++i)
        f_1[t][i] = (ll)f_1[t][i - 1] * f_1[t][1] % mod;
}