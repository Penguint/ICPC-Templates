## 树结点
 - [ ] 封装
 - [ ] 测试

```cpp
struct t_node {
    int d;
    int pa;
    int tin, tout;

    bool is_ancestor(t_node a) { return a.tin <= tin && tout <= a.tout; }
};

// demo
int main() {
    vector<t_node> V(n + 1);
    vector<int> vis(n + 1);
    function<void(int, int, int)> dfs;
    dfs = [&](int u, int depth, int parent) {
        V[u].d = depth;
        V[u].pa = parent;
        V[u].tin = ++timestamp;
        vis[u] = 1;
        for (int v : G[u])
            if (!vis[v])
                dfs(v, depth + 1, u);
        V[u].tout = ++timestamp;
    };
    int timestamp = 0;
    dfs(1, 0, 0);
}
```